Excellent question â€” this is really the heart of why Kubernetes service account tokens can act as an â€œidentity tokenâ€ at all.

Letâ€™s unpack the Kubernetes OIDC model clearly.

â¸»

ğŸ§© 1. Background: Kubernetes as an OIDC issuer

Every Kubernetes cluster acts as its own OpenID Connect (OIDC) identity provider for workloads running inside it.
	â€¢	When a Pod uses a service account, the kubelet injects a JWT token into /var/run/secrets/kubernetes.io/serviceaccount/token.
	â€¢	That JWT is signed by the clusterâ€™s control-plane key (via the API server).
	â€¢	The JWT has standard OIDC-style claims:

{
  "iss": "https://kubernetes.default.svc",
  "sub": "system:serviceaccount:<namespace>:<service-account-name>",
  "aud": "api",
  "kubernetes.io": { ... }
}


	â€¢	The issuer (iss) is the Kubernetes API server URL.
	â€¢	The signing keys are published via the OIDC discovery document.
You can see them at:

https://kubernetes.default.svc/.well-known/openid-configuration
https://kubernetes.default.svc/openid/v1/jwks

(Inside cluster you can reach it via service DNS, outside you may need to proxy.)

So Kubernetes is behaving exactly like a minimal OIDC provider â€” it issues OIDC-compliant JWTs and exposes discovery + JWKS endpoints.

â¸»

ğŸªª 2. The workload identity model

Each service account is a first-class identity.
When you run a Pod under a SA, Kubernetes:
	â€¢	Assigns it a unique sub = system:serviceaccount:<namespace>:<sa>
	â€¢	Signs a token bound to that identity.
	â€¢	The audience (aud) can be restricted (since K8s v1.21+) â€” you can request a token for a specific audience using the TokenRequest API. That allows you to have short-lived, audience-scoped tokens.

So the Kubernetes OIDC token = â€œproof that this pod is this service account.â€

â¸»

ğŸ” 3. Validating a Kubernetes OIDC token (as an external system)

Any external system (like ForgeRock, Vault, or AWS IAM when using IRSA) can validate these tokens if they:
	1.	Trust the issuer (the clusterâ€™s API server OIDC URL).
	2.	Fetch its JWKS from the discovery document.
	3.	Verify the token signature and audience.

Thatâ€™s how AWS IRSA, GCP Workload Identity Federation, and others integrate with Kubernetes: they all treat the cluster as a trusted OIDC provider.

â¸»

âš™ï¸ 4. Inside vs. Outside cluster validation

Context	Access pattern
Inside cluster	https://kubernetes.default.svc/openid/v1/jwks (ClusterIP)
Outside cluster	Expose the OIDC discovery endpoint via ingress or a proxy if you want external systems like ForgeRock to fetch keys.

If ForgeRock runs outside your cluster, you must either:
	â€¢	Expose the OIDC endpoints publicly (with mTLS or IP allowlist), or
	â€¢	Periodically export the JWKS key set out of the cluster (e.g., via automation).

â¸»

ğŸ§± 5. Real-world uses of the model

System	How it uses the Kubernetes OIDC model
AWS IRSA	IAM validates the k8s SA JWT and exchanges it for AWS STS creds
Google Workload Identity	Google STS validates k8s OIDC token â†’ GCP token
Vault	Vaultâ€™s kubernetes auth method validates k8s JWT â†’ issues Vault token
ForgeRock (your case)	ForgeRock can validate the same JWT â†’ issue an OAuth token

So youâ€™re doing the same pattern those systems use â€” just with ForgeRock as your trust anchor instead of AWS/GCP/Vault.

â¸»

ğŸ§­ 6. Key takeaways
	â€¢	Issuer: Kubernetes API server (iss=https://kubernetes.default.svc)
	â€¢	Audience: who the token is intended for (can be customized per request)
	â€¢	Subject: service account identity
	â€¢	Verification: via OIDC discovery + JWKS
	â€¢	Purpose: establishes workload identity (which pod/SA/namespace is this)

â¸»

ğŸš€ 7. Why it matters for your design

When ForgeRock validates a Kubernetes token during your token-exchange or custom client-auth flow:
	â€¢	Itâ€™s just doing what AWS/GCP do â€” trusting Kubernetes as an OIDC IDP.
	â€¢	You donâ€™t need Vault or secrets.
	â€¢	You can fully automate identity based on service accounts.

So the â€œKubernetes OIDC modelâ€ is basically â€œservice accounts = OIDC identitiesâ€, which enables passwordless trust across systems.

â¸»

Would you like me to show you how ForgeRock should be configured to trust that k8s OIDC issuer (discovery + JWKS) â€” i.e., exactly what to fill in on the ForgeRock side?



----
https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication
----
