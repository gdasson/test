Awesome — here are the ready-to-apply Gatekeeper policies (ConstraintTemplates + Constraints) for:
	1.	PVC exclusivity (only one ServiceAccount may mount your PII PVC)
	2.	Deny exec/attach/port-forward for protected pods (by label and/or image prefix) with an SRE allowlist
	3.	Pod hardening (non-root, no privilege escalation, seccomp, read-only FS, drop caps)

I’ve included a tiny Gatekeeper Config prerequisite so the exec policy can look up target Pods.

⸻

0) Prerequisite — Gatekeeper Config (sync Pods/Namespaces)

apiVersion: config.gatekeeper.sh/v1alpha1
kind: Config
metadata:
  name: config
spec:
  sync:
    syncOnly:
      - group: ""
        version: v1
        kind: Pod
      - group: ""
        version: v1
        kind: Namespace

Apply this once per cluster. It allows policies to “see” Pods/Namespaces when evaluating subresources like /exec.

⸻

1) PVC Exclusivity — only pii-writer-sa may mount pii-pvc

1.1 ConstraintTemplate

apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8srestrictpiipvc
spec:
  crd:
    spec:
      names:
        kind: K8sRestrictPiiPVC
      validation:
        openAPIV3Schema:
          type: object
          properties:
            pvcName:
              type: string
            allowedServiceAccount:
              type: string
  targets:
  - target: admission.k8s.gatekeeper.sh
    rego: |
      package k8srestrictpiipvc

      # Deny any Pod that mounts the target PVC unless it uses the allowed SA.
      violation[{"msg": msg}] {
        input.review.kind.kind == "Pod"
        pod := input.review.object

        pvc := input.parameters.pvcName
        sa  := input.parameters.allowedServiceAccount

        some i
        vol := pod.spec.volumes[i]
        vol.persistentVolumeClaim
        vol.persistentVolumeClaim.claimName == pvc

        pod.spec.serviceAccountName != sa

        msg := sprintf("mounting PVC %q is restricted to serviceAccount %q", [pvc, sa])
      }

1.2 Constraint (start as dry-run, then switch to enforce)

apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sRestrictPiiPVC
metadata:
  name: restrict-pii-pvc-mount
spec:
  enforcementAction: dryrun   # change to "deny" after validation
  match:
    kinds:
      - apiGroups: [""]
        kinds: ["Pod"]
  parameters:
    pvcName: "pii-pvc"
    allowedServiceAccount: "pii-writer-sa"


⸻

2) Exec/Attach/Port-forward Deny — protect by label or image prefix, allow SRE group

Mark PII pods with security.yourorg.io/exec-protected: "true" or list protected image prefixes (or both).

2.1 ConstraintTemplate

apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8sdenyexeconprotectedpods
spec:
  crd:
    spec:
      names:
        kind: K8sDenyExecOnProtectedPods
      validation:
        openAPIV3Schema:
          type: object
          properties:
            allowGroups:
              type: array
              items: { type: string }
            labelKey:
              type: string
              description: "Label key that marks pods as protected. Default: security.yourorg.io/exec-protected"
            matchByImagePrefixes:
              type: array
              items: { type: string }
              description: "Optional image prefixes; if any container image startsWith one of these, pod is protected."
  targets:
  - target: admission.k8s.gatekeeper.sh
    rego: |
      package k8sdenyexeconprotectedpods

      default default_label_key = "security.yourorg.io/exec-protected"

      is_exec {
        input.review.kind.kind == "PodExecOptions"
        input.review.requestSubResource == "exec"
      }
      is_attach {
        input.review.kind.kind == "PodAttachOptions"
        input.review.requestSubResource == "attach"
      }
      is_portfwd {
        input.review.kind.kind == "PodPortForwardOptions"
        input.review.requestSubResource == "portforward"
      }

      # Look up the target Pod from Gatekeeper inventory.
      target_pod = pod {
        ns := input.review.namespace
        name := input.review.name
        pod := data.inventory.namespace[ns]["Pod"][name]
      }

      # Protected by label?
      protected_by_label(pod) {
        lk := default_label_key
        count(input.parameters.labelKey) > 0
        lk := input.parameters.labelKey
        pod.metadata.labels[lk] == "true"
      }

      # Protected by image prefix?
      protected_by_image(pod) {
        prefixes := input.parameters.matchByImagePrefixes
        count(prefixes) > 0
        some i
        ci := pod.spec.containers[i].image
        some j
        startswith(ci, prefixes[j])
      }

      protected_by_image(pod) {
        prefixes := input.parameters.matchByImagePrefixes
        count(prefixes) > 0
        pod.spec.initContainers
        some i
        ii := pod.spec.initContainers[i].image
        some j
        startswith(ii, prefixes[j])
      }

      user_in_allowlist {
        some g
        g := input.review.userInfo.groups[_]
        some a
        a := input.parameters.allowGroups[_]
        g == a
      }

      violation[{"msg": msg}] {
        (is_exec || is_attach || is_portfwd)

        pod := target_pod
        protected := protected_by_label(pod) || protected_by_image(pod)

        protected
        not user_in_allowlist

        msg := sprintf("exec/attach/port-forward denied for protected pod %q/%q", [pod.metadata.namespace, pod.metadata.name])
      }

2.2 Constraint (set your group/image prefixes; start as dry-run)

apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sDenyExecOnProtectedPods
metadata:
  name: deny-exec-on-protected
spec:
  enforcementAction: dryrun   # change to "deny" after validation
  match:
    kinds:
      - apiGroups: [""]
        kinds: ["Pod/exec","Pod/attach","Pod/portforward"]
  parameters:
    allowGroups:
      - "oncall-sre@yourorg.com"
    labelKey: "security.yourorg.io/exec-protected"
    matchByImagePrefixes:
      - "registry.example.com/platform/pii-writer:"
      # add other sensitive images/prefixes here

Attach the label to your Deployment/Pod:

metadata:
  labels:
    security.yourorg.io/exec-protected: "true"



⸻

3) Pod Hardening — non-root, no escalation, seccomp, read-only FS, drop caps

3.1 ConstraintTemplate

apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8shardenpod
spec:
  crd:
    spec:
      names:
        kind: K8sHardenPod
      validation:
        openAPIV3Schema:
          type: object
          properties:
            requireSeccomp:
              type: boolean
            requireReadOnlyRootFS:
              type: boolean
  targets:
  - target: admission.k8s.gatekeeper.sh
    rego: |
      package k8shardenpod

      # Check containers and initContainers uniformly
      all_containers(pod, c) {
        c := pod.spec.containers[_]
      }
      all_containers(pod, c) {
        pod.spec.initContainers
        c := pod.spec.initContainers[_]
      }

      # 1) runAsNonRoot
      violation[{"msg": msg}] {
        input.review.kind.kind == "Pod"
        pod := input.review.object
        c := all_containers(pod, _)
        not hasNonRoot(c)
        msg := sprintf("container %q must set securityContext.runAsNonRoot=true", [c.name])
      }
      hasNonRoot(c) {
        c.securityContext.runAsNonRoot == true
      }

      # 2) no privilege escalation
      violation[{"msg": msg}] {
        input.review.kind.kind == "Pod"
        pod := input.review.object
        c := all_containers(pod, _)
        c.securityContext.allowPrivilegeEscalation
        msg := sprintf("container %q must set allowPrivilegeEscalation=false", [c.name])
      }

      # 3) drop all capabilities
      violation[{"msg": msg}] {
        input.review.kind.kind == "Pod"
        pod := input.review.object
        c := all_containers(pod, _)
        not dropped_all_caps(c)
        msg := sprintf("container %q must drop all Linux capabilities", [c.name])
      }
      dropped_all_caps(c) {
        c.securityContext.capabilities.drop[_] == "ALL"
      }

      # 4) seccomp (optional but recommended)
      violation[{"msg": msg}] {
        input.parameters.requireSeccomp == true
        input.review.kind.kind == "Pod"
        pod := input.review.object

        not pod_has_seccomp(pod)
        msg := "seccompProfile.type must be RuntimeDefault at pod or container level"
      }
      pod_has_seccomp(pod) {
        pod.spec.securityContext.seccompProfile.type == "RuntimeDefault"
      }
      pod_has_seccomp(pod) {
        some i
        pod.spec.containers[i].securityContext.seccompProfile.type == "RuntimeDefault"
      }

      # 5) readOnlyRootFilesystem (optional but recommended)
      violation[{"msg": msg}] {
        input.parameters.requireReadOnlyRootFS == true
        input.review.kind.kind == "Pod"
        pod := input.review.object
        c := all_containers(pod, _)
        not c.securityContext.readOnlyRootFilesystem
        msg := sprintf("container %q must set readOnlyRootFilesystem=true (mount writable volumes if needed)", [c.name])
      }

3.2 Constraint (start as dry-run)

apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sHardenPod
metadata:
  name: harden-pods-shared-nodes
spec:
  enforcementAction: dryrun   # change to "deny" after validation
  match:
    kinds:
      - apiGroups: [""]
        kinds: ["Pod"]
  parameters:
    requireSeccomp: true
    requireReadOnlyRootFS: true


⸻

How to roll out safely
	1.	Apply the Config (sync Pods/Namespaces)
	2.	Apply all ConstraintTemplates first
	3.	Apply the Constraints with enforcementAction: dryrun
	4.	Watch Gatekeeper violations, fix apps/specs where needed
	5.	Flip enforcementAction: deny for each constraint in this order:
	•	PVC exclusivity → Exec/attach deny → Pod hardening

If you want, I can now generate a one-file bundle with these (plus a tiny README for your repo), or tailor names (pvcName, SA, label key, SRE group, image prefixes) to your exact environment.
